#!/usr/bin/env bash
# Splinter (https://github.com/artnc/splinter)

set -efu

VERSION='1.2.0'

main() {
  # Collect arguments
  local -r rules_file="$1"
  shift
  local -r src_paths=("$@")

  # Show help message and version number if requested
  if [[ "$rules_file" == '-h' || "$rules_file" == '--help' ]]; then
    echo 'Splinter is a simple, pattern-based linter.'
    echo 'See usage instructions at https://github.com/artnc/splinter'
    echo "Version: $VERSION"
    exit 0
  fi

  # Parse rule file
  local expecting_rule_message=true
  local messages=()
  local regexes=()
  while read -r line; do
    if [[ $line =~ ^\ *$ ]]; then
      # Line contains no non-space chars
      :
    elif [[ $line =~ ^# ]]; then
      # Line is a comment
      :
    elif [ "$expecting_rule_message" = true ]; then
      # Line is a rule message
      messages+=("$line")
      expecting_rule_message=false
    else
      # Line is a rule regex
      regexes+=("$line")
      expecting_rule_message=true
    fi
  done < "$rules_file"

  # Loop through source paths (either files or directories)
  local found_violations=false
  local src_path
  for src_path in "${src_paths[@]}"; do
    # Loop through source files
    local src_file
    while read -r src_file; do
      local src
      src=$(<"$src_file")

      # Loop through rules
      for i in "${!messages[@]}"; do
        local match
        match=$(echo "$src" | grep -nE "${regexes[$i]}" || echo '')

        # Print violation if found
        if [[ ! -z "$match" ]]; then
          echo "$match" \
            | cut -d: -f1 \
            | tr '\n' '\0' \
            | xargs -0 -I 'LINENO' echo "${src_file}:LINENO:${messages[$i]}"
          found_violations=true
        fi
      done
    done < <(find "$src_path" -type f | sort)
  done

  # Exit with error code if violations found
  if [ "$found_violations" = true ]; then
    exit 1
  fi
}

main "$@"
